<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lantern Catch - Happy Birthday Zainul</title>
<style>
  /* Reset & basics */
  * { margin:0; padding:0; box-sizing: border-box; }
  body, html {
    height: 100%;
    background: radial-gradient(ellipse at center, #0a122a 0%, #04081b 100%);
    overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: white;
    user-select: none;
  }
  #game-container {
    max-width: 480px;
    margin: 1em auto;
    position: relative;
  }
  canvas {
    display: block;
    width: 100%;
    height: 640px;
    background: transparent;
    border-radius: 12px;
    box-shadow: 0 0 20px rgba(255 204 102 / 0.3);
  }
  #hud {
    margin: 1em 0 0.5em;
    text-align: center;
    font-weight: 600;
    letter-spacing: 2px;
    font-size: 1.2em;
    color: #ffcc66;
  }
  #overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    visibility: hidden;
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 10;
  }
  #dialog {
    background: #1a2136;
    padding: 2em 2.5em;
    border-radius: 16px;
    text-align: center;
    max-width: 320px;
    box-shadow: 0 4px 20px rgba(255,204,102,0.6);
  }
  #dialog p {
    font-size: 1.4em;
    margin-bottom: 1.2em;
  }
  #dialog button {
    background: linear-gradient(180deg, #ff7b9a, #ff4f7a);
    border: none;
    border-radius: 9999px;
    padding: 0.7em 2.4em;
    color: white;
    font-weight: 700;
    font-size: 1.2em;
    cursor: pointer;
    box-shadow: 0 6px 14px rgba(255,80,120,0.25);
    transition: background 0.25s ease;
  }
  #dialog button:hover {
    background: linear-gradient(180deg, #ff4f7a, #ff7b9a);
  }
  #final-message {
    font-size: 1.5em;
    margin-top: 1em;
    color: #ffdfc1;
    font-weight: 700;
    text-shadow: 0 0 10px #ffb677;
  }
  /* Stars */
  #stars {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 0;
  }
</style>
</head>
<body>
  <div id="game-container">
    <div id="hud">Spell: <span id="next-letter"></span></div>
    <canvas id="game" width="480" height="640"></canvas>
  </div>

  <div id="overlay" role="dialog" aria-modal="true" aria-labelledby="dialog-text">
    <div id="dialog">
      <p id="dialog-text">Do you love Foumi?</p>
      <button id="yes-button">YES</button>
      <div id="final-message" hidden>Foumi loves you most &lt;3</div>
    </div>
  </div>

  <canvas id="stars"></canvas>

<script>
(() => {
  const MESSAGE = "HAPPY BIRTHDAY ZAINUL";
  const LETTERS = MESSAGE.split('');
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const starsCanvas = document.getElementById('stars');
  const starsCtx = starsCanvas.getContext('2d');
  const nextLetterEl = document.getElementById('next-letter');
  const overlay = document.getElementById('overlay');
  const dialogText = document.getElementById('dialog-text');
  const yesButton = document.getElementById('yes-button');
  const finalMessage = document.getElementById('final-message');

  const W = canvas.width;
  const H = canvas.height;

  let basket = {
    x: W/2 - 60,
    y: H - 60,
    width: 120,
    height: 28,
    speed: 8,
    vx: 0
  };

  // Lantern properties
  const lanternRadius = 28;
  const lanternSpeed = 1.6; // pixels per frame

  // Current lantern
  let lantern = null;

  // Letter index we want to catch next
  let nextIndex = 0;

  // Stars for background
  const starsCount = 80;
  let stars = [];

  // Confetti particles
  let confetti = [];

  function initStars() {
    starsCanvas.width = window.innerWidth;
    starsCanvas.height = window.innerHeight;
    stars = [];
    for(let i=0; i<starsCount; i++){
      stars.push({
        x: Math.random()*starsCanvas.width,
        y: Math.random()*starsCanvas.height,
        radius: Math.random()*1.5 + 0.3,
        alpha: Math.random()*0.6 + 0.3,
        delta: (Math.random() * 0.01) + 0.002
      });
    }
  }

  function drawStars(){
    starsCtx.clearRect(0,0,starsCanvas.width, starsCanvas.height);
    stars.forEach(s => {
      s.alpha += s.delta;
      if(s.alpha > 1 || s.alpha < 0.3) s.delta = -s.delta;
      starsCtx.beginPath();
      starsCtx.arc(s.x, s.y, s.radius, 0, 2*Math.PI);
      starsCtx.fillStyle = `rgba(255,255,255,${s.alpha.toFixed(2)})`;
      starsCtx.fill();
    });
  }

  // Create a new lantern object with letter and start x position
  function spawnLantern(){
    const letter = LETTERS[nextIndex];
    const x = Math.random()*(W - lanternRadius*2) + lanternRadius;
    lantern = {
      x: x,
      y: -lanternRadius*2,
      letter: letter,
      radius: lanternRadius,
      caught: false
    };
    nextLetterEl.textContent = letter;
  }

  // Draw lantern with letter on it (simple cartoon style)
  function drawLantern(l){
    const {x, y, radius, letter} = l;

    // Lantern glow
    const grad = ctx.createRadialGradient(x, y, radius*0.3, x, y, radius);
    grad.addColorStop(0, 'rgba(255, 204, 102, 0.9)');
    grad.addColorStop(1, 'rgba(255, 153, 51, 0.4)');

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.ellipse(x, y, radius*0.7, radius, 0, 0, 2*Math.PI);
    ctx.fill();

    // Lantern ribs (vertical lines)
    ctx.strokeStyle = 'rgba(204, 153, 51, 0.7)';
    ctx.lineWidth = 2;
    for(let i=-3; i<=3; i++){
      const lineX = x + (i * radius * 0.15);
      ctx.beginPath();
      ctx.moveTo(lineX, y - radius);
      ctx.lineTo(lineX, y + radius);
      ctx.stroke();
    }

    // Lantern bottom tassel
    ctx.fillStyle = 'rgba(255, 153, 51, 0.9)';
    ctx.beginPath();
    ctx.moveTo(x - radius*0.3, y + radius*0.7);
    ctx.lineTo(x, y + radius*1.2);
    ctx.lineTo(x + radius*0.3, y + radius*0.7);
    ctx.closePath();
    ctx.fill();

    // Letter on lantern
    ctx.fillStyle = '#2b1a00';
    ctx.font = '28px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(letter, x, y);
  }

  // Draw basket (simple rectangle with rim)
  function drawBasket(){
    ctx.fillStyle = '#8b5e3c';
    ctx.fillRect(basket.x, basket.y, basket.width, basket.height);
    ctx.fillStyle = '#a36b45';
    ctx.fillRect(basket.x, basket.y - 6, basket.width, 8);

    // Cloth inside basket
    ctx.fillStyle = '#ffdfc1';
    ctx.fillRect(basket.x + 8, basket.y + 4, basket.width - 16, 6);

    // Basket shadow
    ctx.beginPath();
    ctx.ellipse(basket.x + basket.width/2, basket.y + basket.height + 8, basket.width/2, 8, 0, 0, 2*Math.PI);
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fill();
  }

  // Check if basket caught the lantern (simple rectangle-circle collision)
  function checkCatch(){
    if(!lantern) return false;
    const closestX = Math.max(basket.x, Math.min(lantern.x, basket.x + basket.width));
    const closestY = Math.max(basket.y, Math.min(lantern.y, basket.y + basket.height));
    const dx = lantern.x - closestX;
    const dy = lantern.y - closestY;
    const distance = Math.sqrt(dx*dx + dy*dy);
    return distance < lantern.radius + 4;
  }

  // Confetti particles
  let confettiParticles = [];
  function createConfetti(){
    for(let i=0; i<50; i++){
      confettiParticles.push({
        x: W/2 + (Math.random()*200-100),
        y: H/2 + (Math.random()*40-40),
        vx: (Math.random()-0.5)*4,
        vy: (Math.random()*-3)-2,
        size: Math.random()*6 + 4,
        life: 1500 + Math.random()*1000,
        color: `hsl(${Math.random()*60+30}, 80%, 60%)`
      });
    }
  }
  function drawConfetti(dt){
    confettiParticles = confettiParticles.filter(p => p.life > 0);
    confettiParticles.forEach(p => {
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size*0.5);
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.1;
      p.life -= dt;
    });
  }

  // Game variables
  let lastTime = 0;
  let lanternSpeedY = lanternSpeed;
  let running = true;

  // Controls
  let keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key] = true;
  });
  window.addEventListener('keyup', e => {
    keys[e.key] = false;
  });

  // Touch drag support
  let dragging = false;
  let dragOffsetX = 0;
  canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    if(my > basket.y - 40 && mx > basket.x && mx < basket.x + basket.width){
      dragging = true;
      dragOffsetX = mx - basket.x;
      canvas.style.cursor = 'grabbing';
    }
  });
  window.addEventListener('mousemove', e => {
    if(dragging){
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      basket.x = mx - dragOffsetX;
      if(basket.x < 0) basket.x = 0;
      if(basket.x > W - basket.width) basket.x = W - basket.width;
    }
  });
  window.addEventListener('mouseup', e => {
    dragging = false;
    canvas.style.cursor = '';
  });
  canvas.addEventListener('touchstart', e => {
    const rect = canvas.getBoundingClientRect();
    const t = e.touches[0];
    const mx = t.clientX - rect.left;
    const my = t.clientY - rect.top;
    if(my > basket.y - 40 && mx > basket.x && mx < basket.x + basket.width){
      dragging = true;
      dragOffsetX = mx - basket.x;
    }
  }, {passive:false});
  window.addEventListener('touchmove', e => {
    if(dragging){
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      const mx = t.clientX - rect.left;
      basket.x = mx - dragOffsetX;
      if(basket.x < 0) basket.x = 0;
      if(basket.x > W - basket.width) basket.x = W - basket.width;
    }
  }, {passive:false});
  window.addEventListener('touchend', e => {
    dragging = false;
  });

  // Show overlay with dialog
  function showOverlay(){
    overlay.style.visibility = 'visible';
    overlay.style.opacity = '1';
  }
  // Hide overlay
  function hideOverlay(){
    overlay.style.visibility = 'hidden';
    overlay.style.opacity = '0';
  }

  yesButton.onclick = () => {
    dialogText.textContent = '';
    yesButton.style.display = 'none';
    finalMessage.hidden = false;
    createConfetti();
  };

  // Spawn first lantern
  spawnLantern();

  // Game loop
  function gameLoop(timestamp){
    if(!lastTime) lastTime = timestamp;
    const dt = timestamp - lastTime;
    lastTime = timestamp;

    // Move basket
    if(keys['ArrowLeft']) basket.x -= basket.speed;
    if(keys['ArrowRight']) basket.x += basket.speed;
    if(basket.x < 0) basket.x = 0;
    if(basket.x > W - basket.width) basket.x = W - basket.width;

    // Move lantern down
    if(lantern){
      lantern.y += lanternSpeedY;

      // Check catch
      if(checkCatch()){
        nextIndex++;
        if(nextIndex >= LETTERS.length){
          lantern = null;
          running = false;
          showOverlay();
        } else {
          spawnLantern();
        }
      } else if(lantern.y - lantern.radius > H){
        // Missed lantern, retry same letter by respawning
        spawnLantern();
      }
    }

    // Clear canvas
    ctx.clearRect(0,0,W,H);

    // Draw stars
    drawStars();

    // Draw lantern
    if(lantern) drawLantern(lantern);

    // Draw basket
    drawBasket();

    // Draw confetti
    drawConfetti(dt);

    // Update HUD letter
    nextLetterEl.textContent = LETTERS[nextIndex] || '';

    if(running) requestAnimationFrame(gameLoop);
  }

  // Resize stars canvas to cover full viewport
  function resizeStars(){
    starsCanvas.width = window.innerWidth;
    starsCanvas.height = window.innerHeight;
  }
  window.addEventListener('resize', () => {
    resizeStars();
    initStars();
  });
  resizeStars();
  initStars();

  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>
